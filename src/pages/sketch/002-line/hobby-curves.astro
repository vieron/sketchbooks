---
import Sketch from "../../../layouts/Sketch.astro";
---

<Sketch title="003 Line">
  <script>
    import p5 from "p5";
    import { createHobbyBezier } from "hobby-curve";

    window.sketch = (p) => {
      // poisson disc
      let tries: number;
      let radius: number;
      let lineWeight: number;

      let cellSize: number;
      let gridWidth: number;
      let gridHeight: number;
      let margin: number;

      let grid: (undefined | p5.Vector)[] = [];
      const active: p5.Vector[] = [];
      const ordered: p5.Vector[] = [];
      let cols: number, rows: number;

      // general params
      const framesPerSecond = 1;
      const stepsPerFrame = 20000;

      const pointsPerLine = [3, 3];
      const strokeMultiplier = 1.4;
      const marginRange = [20, 140];
      let hue: number;

      p.setup = () => {
        p.noLoop();
        p.createCanvas(p.windowWidth, p.windowHeight);
        p.strokeWeight(4);
        p.colorMode(p.HSB);
        p.frameRate(framesPerSecond);

        // params
        radius = p.floor(p.random(10, 15));
        tries = 30;
        lineWeight = radius * 0.85;
        hue = p.floor(p.random(100, 200));

        // computed params
        cellSize = radius / Math.sqrt(2); // cell width;
        margin = p.map(p.width, 0, 4000, marginRange[0], marginRange[1]);
        gridWidth = p.width - margin * 2;
        gridHeight = p.height - margin * 2;

        // STEP 0
        cols = p.floor(gridWidth / cellSize);
        rows = p.floor(gridHeight / cellSize);
        for (let i = 0; i < cols * rows; i++) {
          grid[i] = undefined;
        }

        // STEP 1
        const x = gridWidth / 2;
        const y = gridHeight / 2;
        const i = p.floor(x / cellSize);
        const j = p.floor(y / cellSize);
        const pos = p.createVector(x, y);

        grid[i + j * cols] = pos;

        active.push(pos);
      };

      p.draw = () => {
        p.background(255);
        p.translate(margin, margin);

        for (var steps = 0; steps < stepsPerFrame; steps++) {
          if (active.length > 0) {
            //   const randIndex = floor(random(active.length));
            const randIndex = active.length - 1;
            const pos = active[randIndex];

            let found = false;
            // tries
            for (let n = 0; n < tries; n++) {
              const sample = p5.Vector.random2D();
              const mag = p.random(radius, 2 * radius);

              sample.setMag(mag);
              sample.add(pos);

              const col = p.floor(sample.x / cellSize);
              const row = p.floor(sample.y / cellSize);
              const cellIndex = col + row * cols;

              // find valid neighbor
              if (
                col >= 0 &&
                row >= 0 &&
                col < cols &&
                row < rows &&
                !grid[cellIndex]
              ) {
                let valid = true;
                for (let i = -1; i <= 1; i++) {
                  for (let j = -1; j <= 1; j++) {
                    const index = col + i + (row + j) * cols;
                    const neighbor = grid[index];

                    if (neighbor) {
                      const d = p5.Vector.dist(sample, neighbor);

                      if (d < radius) {
                        valid = false;
                        break;
                      }
                    }
                  }
                }

                if (valid) {
                  found = true;
                  grid[cellIndex] = sample;

                  active.push(sample);
                  ordered.push(sample);
                  break;
                }
              }
            }

            if (!found) {
              active.splice(randIndex, 1);
            }
          }
        }

        let currentLine: p5.Vector[] = [];
        // let localPointsPerLine: number = 30;
        let localPointsPerLine: number = p.floor(
          p.random(pointsPerLine[0], pointsPerLine[1])
        );

        for (var i = 0; i < ordered.length; i++) {
          const point = ordered[i];

          // debugging point
          // stroke(color("red"));
          // strokeWeight(2);
          // noFill();
          // circle(point.x, point.y, 3);

          currentLine.push(point);

          if (currentLine.length === localPointsPerLine) {
            const hobbyPoints = createHobbyBezier(currentLine, {
              tension: 1,
              cyclic: false,
            });

            // first and last point
            // fill(0, 0, 0);
            // noStroke();
            // circle(currentLine[0].x, currentLine[0].y, lineWeight * 1.6);
            // circle(
            //   currentLine[localPointsPerLine - 1].x,
            //   currentLine[localPointsPerLine - 1].y,
            //   lineWeight * 1.6
            // );

            // background line
            p.noFill();
            p.stroke(0, 0, 0, 0.6);
            p.strokeWeight(lineWeight * strokeMultiplier);
            p.beginShape();
            p.vertex(currentLine[0].x, currentLine[0].y);
            hobbyPoints.forEach(({ startControl, endControl, point }) => {
              p.bezierVertex(
                startControl.x,
                startControl.y,
                endControl.x,
                endControl.y,
                point.x,
                point.y
              );
            });
            p.endShape();

            // foreground line
            p.noFill();
            p.stroke(hue, i % 255, p.floor(p.random(100, 244)));
            // stroke(color(random(255), random(255), random(255)));
            p.strokeWeight(lineWeight);
            p.beginShape();
            p.vertex(currentLine[0].x, currentLine[0].y);
            hobbyPoints.forEach(({ startControl, endControl, point }) => {
              p.bezierVertex(
                startControl.x,
                startControl.y,
                endControl.x,
                endControl.y,
                point.x,
                point.y
              );
            });
            p.endShape();

            // empty line
            localPointsPerLine = p.floor(
              p.random(pointsPerLine[0], pointsPerLine[1])
            );
            currentLine = [];
          }
        }
      };
    };
  </script>
</Sketch>
