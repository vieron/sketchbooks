---
import Sketch from "../../../layouts/Sketch.astro";
---

<Sketch title="003 Line">
  <script>
    import p5 from "p5";
    import { createHobbyBezier } from "hobby-curve";

    // poisson disc
    let tries: number;
    let radius: number;
    let lineWeight: number;

    let cellSize: number;
    let gridWidth: number;
    let gridHeight: number;
    let margin: number;

    let grid: (undefined | p5.Vector)[] = [];
    const active: p5.Vector[] = [];
    const ordered: p5.Vector[] = [];
    let cols: number, rows: number;

    // general params
    const framesPerSecond = 1;
    const stepsPerFrame = 20000;

    const pointsPerLine = [3, 3];
    const strokeMultiplier = 1.4;
    const marginRange = [20, 140];
    let hue: number;

    window.setup = () => {
      noLoop();
      createCanvas(windowWidth, windowHeight);
      strokeWeight(4);
      colorMode(HSB);
      frameRate(framesPerSecond);

      // params
      radius = floor(random(10, 15));
      tries = 30;
      lineWeight = radius * 0.85;
      hue = floor(random(100, 200));

      // computed params
      cellSize = radius / Math.sqrt(2); // cell width;
      margin = map(width, 0, 4000, marginRange[0], marginRange[1]);
      gridWidth = width - margin * 2;
      gridHeight = height - margin * 2;

      // STEP 0
      cols = floor(gridWidth / cellSize);
      rows = floor(gridHeight / cellSize);
      for (let i = 0; i < cols * rows; i++) {
        grid[i] = undefined;
      }

      // STEP 1
      const x = gridWidth / 2;
      const y = gridHeight / 2;
      const i = floor(x / cellSize);
      const j = floor(y / cellSize);
      const pos = createVector(x, y);

      grid[i + j * cols] = pos;

      active.push(pos);
    };

    window.draw = () => {
      background(255);
      translate(margin, margin);

      for (var steps = 0; steps < stepsPerFrame; steps++) {
        if (active.length > 0) {
          //   const randIndex = floor(random(active.length));
          const randIndex = active.length - 1;
          const pos = active[randIndex];

          let found = false;
          // tries
          for (let n = 0; n < tries; n++) {
            const sample = p5.Vector.random2D();
            const mag = random(radius, 2 * radius);

            sample.setMag(mag);
            sample.add(pos);

            const col = floor(sample.x / cellSize);
            const row = floor(sample.y / cellSize);
            const cellIndex = col + row * cols;

            // find valid neighbor
            if (
              col >= 0 &&
              row >= 0 &&
              col < cols &&
              row < rows &&
              !grid[cellIndex]
            ) {
              let valid = true;
              for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                  const index = col + i + (row + j) * cols;
                  const neighbor = grid[index];

                  if (neighbor) {
                    const d = p5.Vector.dist(sample, neighbor);

                    if (d < radius) {
                      valid = false;
                      break;
                    }
                  }
                }
              }

              if (valid) {
                found = true;
                grid[cellIndex] = sample;

                active.push(sample);
                ordered.push(sample);
                break;
              }
            }
          }

          if (!found) {
            active.splice(randIndex, 1);
          }
        }
      }

      let currentLine: p5.Vector[] = [];
      // let localPointsPerLine: number = 30;
      let localPointsPerLine: number = floor(
        random(pointsPerLine[0], pointsPerLine[1])
      );

      for (var i = 0; i < ordered.length; i++) {
        const point = ordered[i];

        // debugging point
        // stroke(color("red"));
        // strokeWeight(2);
        // noFill();
        // circle(point.x, point.y, 3);

        currentLine.push(point);

        if (currentLine.length === localPointsPerLine) {
          const hobbyPoints = createHobbyBezier(currentLine, {
            tension: 1,
            cyclic: false,
          });

          // first and last point
          // fill(0, 0, 0);
          // noStroke();
          // circle(currentLine[0].x, currentLine[0].y, lineWeight * 1.6);
          // circle(
          //   currentLine[localPointsPerLine - 1].x,
          //   currentLine[localPointsPerLine - 1].y,
          //   lineWeight * 1.6
          // );

          // background line
          noFill();
          stroke(0, 0, 0, 0.6);
          strokeWeight(lineWeight * strokeMultiplier);
          beginShape();
          vertex(currentLine[0].x, currentLine[0].y);
          hobbyPoints.forEach(({ startControl, endControl, point }) => {
            bezierVertex(
              startControl.x,
              startControl.y,
              endControl.x,
              endControl.y,
              point.x,
              point.y
            );
          });
          endShape();

          // foreground line
          noFill();
          stroke(hue, i % 255, floor(random(100, 244)));
          // stroke(color(random(255), random(255), random(255)));
          strokeWeight(lineWeight);
          beginShape();
          vertex(currentLine[0].x, currentLine[0].y);
          hobbyPoints.forEach(({ startControl, endControl, point }) => {
            bezierVertex(
              startControl.x,
              startControl.y,
              endControl.x,
              endControl.y,
              point.x,
              point.y
            );
          });
          endShape();

          // empty line
          localPointsPerLine = floor(
            random(pointsPerLine[0], pointsPerLine[1])
          );
          currentLine = [];
        }
      }
    };
  </script>
</Sketch>
