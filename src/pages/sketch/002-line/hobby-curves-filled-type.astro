---
import Sketch from "../../../layouts/Sketch.astro";
---

<Sketch title="003 Line">
  <script>
    import p5 from "p5";
    import poissonDisk from "../../../sketch-utils/poisson-disk";
    import { chooseWeighted } from "../../../sketch-utils/random";
    import {
      createTextImage,
      getFontSizeToFit,
    } from "../../../sketch-utils/type";
    import type { FontAttributes } from "../../../sketch-utils/type";
    import { drawHobbyLines } from "../../../sketch-utils/hobby-lines";

    window.sketch = (p) => {
      // poisson disc
      let tries: number;
      let radius: number;
      let lineWeight: number;
      let lineTension: () => number;

      let margin: number;
      let img: ImageData;

      // general params
      let text: string;

      let pointsPerLine: () => number;
      let strokeWidth: number;
      let marginRange: number[];

      let bgColor: string;
      let fgColorHue: number; // 0-360
      let strokeColor: p5.Color;
      let fgPalette: [number, p5.Color][];

      let fontName: string;
      let fontSize: number;
      let fontWeight: number;

      let angleVariation: number;
      let font: p5.Font;

      p.preload = async () => {
        // font = p.loadFont("/public/fonts/Atop.ttf");
        // font = p.loadFont("/public/fonts/Humane-Bold.otf");
        // font = p.loadFont("/public/fonts/Thunder-ExtraBoldLC.otf");
      };

      p.setup = () => {
        p.noLoop();
        p.createCanvas(p.windowWidth, p.windowHeight);
        p.colorMode(p.HSB);
        // frameRate(framesPerSecond);
        // p.textFont(font);

        // params
        radius = p.map(p.width, 300, 2000, 1.5, 8);
        tries = 30;
        text = "FORM";
      };

      p.draw = () => {
        lineWeight = p.map(p.width, 300, 2000, 2, 12);
        strokeWidth = p.map(p.width, 300, 2000, 0.2, 1.4); //px
        pointsPerLine = () =>
          chooseWeighted(p, [
            [0.8, 3],
            [0.2, 2],
          ]);
        lineTension = () =>
          chooseWeighted(p, [
            [0.6, 0.8],
            [0.2, 1],
          ]);
        marginRange = [20, 200];

        // computed params
        bgColor = "#FFF";
        fgColorHue = p.floor(p.random(0, 360)); // 345;
        strokeColor = p.color(fgColorHue, 80, 30);
        fgPalette = [
          [0.5, p.color(fgColorHue, 100, 100)],
          [0.2, p.color(fgColorHue, 80, 100)],
          [0.2, p.color(fgColorHue, 100, 80)],
          [0.2, p.color(fgColorHue, 50, 100)],
          [0.2, p.color(fgColorHue, 100, 50)],
          [0.1, p.color(fgColorHue, 20, 100)],
        ];

        fontName = p.random([
          "system-ui",
          // "Atop",
          // "Humane-Bold",
          // "Thunder-ExtraBoldLC",
          // "Avenir, Montserrat, Corbel, 'URW Gothic', source-sans-pro",
          // "ArchivoBlack-Regular",
          // "JustBubbleRegular",
        ]);
        fontWeight = 900;

        angleVariation = p.QUARTER_PI / 10;
        margin = p.map(p.width, 300, 4000, marginRange[0], marginRange[1]);

        // init
        p.background(bgColor);

        const fontAttributes: FontAttributes = {
          fontName,
          fontSize,
          fontWeight,
          letterSpacing: "0.075em",
        };

        // calculate fontSize to fit
        fontSize = getFontSizeToFit({
          textSample: text,
          width: p.width - margin * 2,
          height: p.width - margin * 2,
          ...fontAttributes,
        });
        fontAttributes.fontSize = fontSize;

        // BACKGROUND
        //
        const bgOffset = 100;
        const bgPoints = poissonDisk(p, {
          radius: 5,
          tries: 30,
          width: p.width + bgOffset * 2,
          height: p.height + bgOffset * 2,
        });

        p.push();
        p.translate(-bgOffset, -bgOffset);
        drawHobbyLines(p, bgPoints, {
          pointsPerLine: () => 3,
          strokeColor: p.color(bgColor),
          strokeWidth: 2,
          lineWeight: 3,
          fgPalette: [
            [0.02, p.color(fgColorHue, 48, 100)],
            [0.1, p.color(fgColorHue, 38, 100)],
            [0.1, p.color(fgColorHue, 28, 100)],
            [0.1, p.color(fgColorHue, 18, 100)],
          ],
        });
        p.pop();

        //
        // COMPUTE LETTERS
        //
        const letters = text.split("").map((char, i) => {
          img = createTextImage({
            textSample: char,
            ...fontAttributes,
          });

          const points = poissonDisk(p, {
            radius,
            tries,
            width: img.width,
            height: img.height,
          });

          return {
            img,
            points,
          };
        });

        const lettersSize = letters.reduce(
          ({ width, height }, { img }) => ({
            width: width + img.width,
            height: Math.max(height, img.height),
          }),
          { width: 0, height: 0 }
        );
        const baseX = p.width / 2 - lettersSize.width / 2;
        const baseY = p.height / 2 - lettersSize.height / 2;

        //
        // DRAW LETTERS
        //
        p.translate(baseX, baseY);
        let xOffset = 0;

        letters.forEach(({ img, points }, i) => {
          p.push();
          p.translate(xOffset, 0);

          // rotate from center
          p.translate(img.width / 2, img.height / 2);
          p.rotate(p.random(-angleVariation, angleVariation));
          p.translate(-img.width / 2, -img.height / 2);

          // draw letter
          drawHobbyLines(p, points, {
            pointsPerLine,
            strokeColor,
            strokeWidth,
            lineWeight,
            fgPalette,
            skipPoint: (point) => {
              const index =
                Math.floor(
                  Math.floor(point.y) * img.width + Math.floor(point.x)
                ) * 4;
              const alpha = img.data[index + 3];

              // discard points outside of typography shape
              if (alpha === 0 || typeof alpha === "undefined") {
                return true;
              }

              return false;
            },
          });
          p.pop();

          xOffset += img.width;
        });
      };
    };
  </script>
</Sketch>
